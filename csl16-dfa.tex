% arara: pdflatex
% arara: bibtex
% arara: pdflatex
% arara: pdflatex
\documentclass[a4paper,USenglish]{lipics-v2016}
%for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle


\usepackage{csl-dfa}% custom macros


% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{A sample title\footnote{This work was partially supported by someone.}}
\titlerunning{A Sample Running Title}% optional

\author{Henry DeYoung}
\author{Frank Pfenning}
\affil{Computer Science Department, Carnegie Mellon University, Pittsburgh, PA USA\\
  \texttt{\{hdeyoung,fp\}@cs.cmu.edu}}
\authorrunning{H. DeYoung and F. Pfenning}

\Copyright{Henry DeYoung and Frank Pfenning}%LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
 \end{abstract}

\section{Introduction}\label{sec:introduction}


\begin{lstlisting}[caption={Useless code},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
for i:=maxint to 0 do 
begin 
    j:=square(root(i));
end;
\end{lstlisting}


\section{Intuitionistic linear logic with least fixed points}\label{sec:linear-logic}

In this \lcnamecref{sec:linear-logic}, we describe a fragment of intuitionistic linear logic with least fixed points.
Propositions are given by the grammar
\begin{equation*}
  A \Coloneqq \plus*[\ell \in L]{\ell{:}A_{\ell}} \mid A_1 \tensor A_2 \mid \one \mid \indtype{X.A} \mid X
  \,,
\end{equation*}
where $\plus*[\ell \in L]{\ell{:}A_{\ell}}$ is a labeled $n$-ary additive disjunction over the set $L$ of labels, $A_1 \tensor A_2$ and $\one$ are multiplicative conjunction and its unit, and $\indtype{X.A}$ is the least fixed point that is the least solution to the equation $X = A$.
Because all of the connectives in this fragment are covariant, notice that the least fixed points necessarily satisfy the standard strict positivity condition that guarantees well-definedness.
% We enforce the standard strict positivity requirement on inductive types to ensure that they are well-defined.
%
As usual, contexts, $\lctx$, are finite multisets of propositions:
\begin{equation*}
  \lctx \Coloneqq \lctxe \mid \lctx, A
  \,.
\end{equation*}

We use a sequent calculus presentation in which sequents have the form $\seq{\lctx |- A}$.
The right and left introduction rules for $\plus$, $\tensor$, and $\one$, along with cut and identity rules are given in \cref{fig:linear-logic}.
%
\begin{figure}
  \begin{mathpar}
    \infer[{\jrule[_A]{CUT}}]{\seq{\lctx , \lctx' |- \spawn{P; Q} :: z:C}}{
      \seq{\lctx |- P :: x:A} &
      \seq{\lctx' , x:A |- Q :: z:C}}
    \qquad
    \infer[{\jrule[_A]{ID}}]{\seq{x:A |- \fwd{z}{x} :: z:A}}{
      }
    %
    \\
    %
    \infer[\rrule{\plus}]{\seq{\lctx |- \select{x}{\kay; P} :: x:\plus*[\ell \in L]{\ell{:}A_{\ell}}}}{
      \seq{\lctx |- P :: x:A_{\kay}} &
      \text{($\kay \in L$)}}
    \qquad
    \infer[\lrule{\plus}]{\seq{\lctx' , x:\plus*[\ell \in L]{\ell{:}A_{\ell}} |- \case{x}[\ell \in L]{\ell => Q_{\ell}} :: z:C}}{
      \forallseq{\ell \in L}{\seq{\lctx' , x:A_{\ell} |- Q_{\ell} :: z:C}}}
    %
    \\
    %
    \infer[\rrule{\tensor}]{\seq{\lctx_1 , \lctx_2 |- \send{x}{P_1; P_2} :: x:A_1 \tensor A_2}}{
      \seq{\lctx_1 |- P_1 :: y:A_1} &
      \seq{\lctx_2 |- P_2 :: x:A_2}}
    \qquad
    \infer[\lrule{\tensor}]{\seq{\lctx' , x:A_1 \tensor A_2 |- \recv{x}{y <- Q} :: z:C}}{
      \seq{\lctx' , y:A_1 , x:A_2 |- Q :: z:C}}
    %
    \\
    %
    \infer[\rrule{\one}]{\seq{\lctxe |- \close{x} :: x:\one}}{
      }
    \qquad
    \infer[\lrule{\one}]{\seq{\lctx' , x:\one |- \wait{x}{Q} :: z:C}}{
      \seq{\lctx' |- Q :: z:C}}
  \end{mathpar}
  \caption{Inference rules for a sequent calculus presentation of a fragment of linear logic\label{fig:linear-logic}}
\end{figure}
%
Rather than giving right and left introduction rules for $\mu$, it will be convenient to treat inductive types and their proofs \vocab{equi-recursively}.
We will identify $\indtype{X.A}$ with its unrolling $[(\indtype{X.A})/X]A$, 


\section{Proofs as \aclp*{DFA}}\label{sec:proofs-as-dfas}

\subsection{\Aclp*{DFA}}\label{sec:dfas}

A \vocab{deterministic finite automaton}~(\acs{DFA}) $M$ is a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where
$Q$ is a finite set of states,
$\Sigma$ is a finite alphabet of input symbols $a$,
$\delta\colon Q \times \Sigma \to Q$ is a total transition function,
% function that describes the state transitions upon reading an input letter,
$q_0 \in Q$ is the initial state, and
$F \subseteq Q$ is a set of accepting states.
% For convenience in speaking of \emph{the} language accepted by the \ac{DFA} $M$, it is typical to also fix a starting state, $q_0 \in Q$, for all computations of $M$. % the \ac{DFA} $M$.
% We choose not to do so.
The set of all finite strings over alphabet $\Sigma$ is written as $\Sigma^*$, with $\emp$ denoting the empty string.

A \vocab{computation} of % the automaton
$M$ on the input string $w = a_1 a_2 \dotsb a_n \in \Sigma^*$
is a sequence of states $q_0, q_1, \dots, q_n$ such that $\delta(q_i, a_{i+1}) = q_{i+1}$ for each $0 \leq i < n$.
% The \ac{DFA}
$M$ is said to \vocab{accept} string $w$ if there exists a computation on $w$ that ends in an accepting state, $q_n \in F$; otherwise, $M$ is said to \vocab{reject} string $w$.

Alternatively, one may extend the transition function $\delta$, which operates on symbols, to a function $\delta^*\colon Q \times \Sigma^* \to Q$, which operates on strings.
% the lifting of the transition function $\delta$ from letters to words, by induction on the length of the input word:
\begin{align*}
  \delta^*(q, \emp) &= q \\
  \delta^*(q, a w') &= \delta^*(q', w') \text{\,, where $\delta(q, a) = q'$}
\end{align*}
It's straightforward to show, by induction on the length of the string $w$, that $M$ accepts $w$ if and only if $\delta^*(q_0, w) \in F$.

\begin{figure}
  \begin{tikzpicture}
    \graph [grow right sep=2em, math nodes, nodes={state}] {
      0 / "\mathclap{\state{even}}" [initial, initial text=, accepting]
       -> [bend left, "$\isym{b}$"]
      1 / "\mathclap{\smash{\state{odd}}\vphantom{\state{even}}}"
       -> [bend left, "$\isym{b}$"]
      0;
      %
      0 -> [loop above, "$\isym{a}$"] 0;
      1 -> [loop above, "$\isym{a}$"] 1;
    };
  \end{tikzpicture}
  %
  % \begin{gather*}
  %   even = \caseL{
  %            \isym{a} => even
  %          | \isym{b} => odd
  %          | \eow => \waitL{\selectR{\acc ; \closeR}}}
  %   %
  %   \\
  %   %
  %   odd = \caseL{
  %           \isym{a} => odd
  %         | \isym{b} => even
  %         | \eow => \waitL{\selectR{\rej ; \closeR}}}
  % \end{gather*}
  \caption{The transition diagram for \iac*{DFA} that recognizes strings over the alphabet $\{\isym{a}, \isym{b}\}$ that contain an even number of $\isym{b}$s.\label{fig:dfa-example}}
\end{figure}
%
\begin{example}
\Cref{fig:dfa-example} shows the transition diagram for \iac{DFA} that recognizes finite strings over the alphabet $\Sigma = \{\isym{a}, \isym{b}\}$ that contain an even number of $\isym{b}$s.
The starting state, as indicated by the unlabeled arrow, is $\state{even}$; it is also an accepting state, as indicated by its doubled outline.
% corresponds to having read an even number of $\isym{b}$s so far; likewise, the state $\state{odd}$ corresponds to having read an odd number of $\isym{b}$s so far.
This \ac{DFA} accepts the string $\isym{b} \isym{a} \isym{b}$ because there is a path corresponding to $\isym{b} \isym{a} \isym{b}$ from the starting state, $\state{even}$, to an accepting state; % , namely $\state{even}$.
this \ac{DFA} rejects the string $\isym{b} \isym{a}$ because the path corresponding to $\isym{b} \isym{a}$ from the starting state ends at a rejecting state.
\end{example}

Although some definitions of \acp{DFA} allow the transition function $\delta$ to be a partial function, notice that we demand that $\delta$ is total.
Totality ensures that \iac{DFA} never gets stuck while reading an input symbol;
this will be crucial for the correspondence between \ac{DFA} computations and cut reductions that we give in \cref{sec:curry-howard-dfas}.
In demanding totality, there is no loss of expressiveness: one can always introduce a distinguished rejecting state that acts as a sink for any transitions that would have been left undefined under a partial transition function.

% Notice our demand that the transition function $\delta$ be a total function.
% Some definitions of \acp{DFA} allow transition functions to be partial functions, but notice that we demand the transition function be a total function.
% In making this demand, there is no loss of expressiveness, however, because one may always introduce a sink state that is not accepting.

\section{Conclusion}\label{sec:conclusion}

\subparagraph*{Acknowledgements.}

We want to thank \dots


%%
%% Bibliography
%%

\bibliography{csl2016}

\end{document}
